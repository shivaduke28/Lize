#pragma kernel CSVertex

struct Vertex
{
    float3 Position;
};

// object space position
StructuredBuffer<Vertex> _VertexBuffer;
float4x4 _ModelToWorldMatrix;
float4x4 _WorldToCameraMatrix;
float4 _CameraData; // width, height, near, far

// [0,1]^3 position
RWStructuredBuffer<Vertex> _VertexResultBuffer;

[numthreads(64,1,1)]
void CSVertex(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    float3 positionOS = _VertexBuffer[index].Position;
    float4 positionWS = mul(_ModelToWorldMatrix, float4(positionOS, 1));
    float3 positionCS = mul(_WorldToCameraMatrix, float4(positionWS.xyz, 1));

    Vertex v;
    v.Position = float3(
        (positionCS.x + _CameraData.x * 0.5) / _CameraData.x,
        (positionCS.y + _CameraData.y * 0.5) / _CameraData.y,
        (positionCS.z - _CameraData.z) / _CameraData.w
    );
    _VertexResultBuffer[index] = v;
}


#pragma kernel CSTriangle

struct Triangle
{
    uint3 Indices;
};

uint _TexelSize;
StructuredBuffer<Triangle> _TriangleBuffer;
RWTexture3D<float4> _TargetTex;

void Draw(float3 p)
{
    if (any(p < 0) || any(p > 1)) return;
    uint3 t = p * _TexelSize;
    _TargetTex[t] = 1;
}

[numthreads(64,1,1)]
void CSTriangle(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    Triangle tri = _TriangleBuffer[index];
    uint3 indices = tri.Indices;

    // [0, 1]^3
    float3 p0 = _VertexResultBuffer[indices.x].Position;
    float3 p1 = _VertexResultBuffer[indices.y].Position;
    float3 p2 = _VertexResultBuffer[indices.z].Position;

    Draw(p0);
    Draw(p1);
    Draw(p2);

    // uint3 t0 = p0 * _TexelSize;
    // uint3 t1 = p1 * _TexelSize;
    // uint3 t2 = p2 * _TexelSize;
    //
    // _TargetTex[t0] = float4(1, 0, 0, 1);
    // _TargetTex[t1] = float4(0, 1, 0, 1);
    // _TargetTex[t2] = float4(0, 0, 1, 1);
}
